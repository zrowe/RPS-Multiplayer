//
// Player 1 is the left-hand player.   
// Player 2 is the right-hand player.  
// It makes no difference when player 1 or 2 comes online. Since after the 1st match, either
// player may leave and the next arriving player will take that player's side.

// Whomever is the 1st of the 2 players (the one who has been there "longer"), 
// gets the first choice of weapons.

// Upon connection, test of I am:
//   'first' (alone),
//   'second' (have an adversary), or 
//   'waiting' (there are already 2 players).

//Upon connection:
//   push a child which will contain all attributes for me (player or waiter)
//   tell firebase to destroy the child upon disconnect.





// Notes to self:
//    I am always me and not the 'other player'
//    There is no persistance.  IE, reloading will cause entry as new player.
//     



// Initial Values
var debug = 1 // my handy console debug flag
var numConnections = 0; // number of connections
var name = "";
var playerRef; // handle to me in firebase
var playerKey = ""; // my key in firebase
var test = 0;

// Initialize Firebase
var config = {
    apiKey: "AIzaSyAPxhfFl_Yf_ZCoNC9iewYcA7WU2BQ26zk",
    authDomain: "multiplayer-rps-c1bb6.firebaseapp.com",
    databaseURL: "https://multiplayer-rps-c1bb6.firebaseio.com",
    projectId: "multiplayer-rps-c1bb6",
    storageBucket: "multiplayer-rps-c1bb6.appspot.com",
    messagingSenderId: "709965254417"
};
firebase.initializeApp(config);

var database = firebase.database();


// All of our players (connections) will be stored in this directory.
var playersRef = database.ref("/players"); // child containing all the online players
var connectedRef = database.ref(".info/connected");

// When the client's connection state changes...
connectedRef.on("value", function(snap) {
    // If they are connected..
    if (snap.val()) {
        // Add me to the players list. A unique key is generated by push().
        // They are ordered by the current time, so the resulting list of items 
        // will be chronologically sorted.  This is the handle to "me".
        playerRef = playersRef.push(true); 
        playerKey = playerRef.key;
        console.log(playerKey);
        // Remove me from the players list when I disconnect.
        playerRef.onDisconnect().remove();
    }
});

// When first loaded or whenever the players list changes, i get a callback for each player
// This is veryu tricky.  UPdates to any child's data will cause an event.  
playersRef.on("value", function(snap) {

    // The number of players online is the number of children in the connections list.
    // if less than 3 connections, I get to play
    // otherwise I am waiting to play and there are numChildren-2 waiting
    numConnections = (snap.numChildren());
    console.log(numConnections);




    if (numConnections < 3) {
        initializePlayer();
    } else {
        placeOnWaitlist();
    }
});


function initializePlayer() {
    if (debug) { console.log("function initializePlayer: "); }
    playerRef.update({ status: "playing" })
}

function placeOnWaitlist() {
    if (debug) { console.log("function placeOnWaitlist: "); }
    playerRef.update({ status: "Waiting" })
}



// ========================================
// Start Button Click
$("#add-user").on("click", function(event) {
    event.preventDefault();


    // Don't forget to provide initial data to your Firebase database.
    name = $("#name-input").val().trim();
    email = $("#email-input").val().trim();
    age = $("#age-input").val().trim();
    comment = $("#comment-input").val().trim();

    // Code for the push
    dataRef.ref().push({

        name: name,
        email: email,
        age: age,
        comment: comment,
        dateAdded: firebase.database.ServerValue.TIMESTAMP
    });
});